From 4d098b053690861992f9daa4e3195b31295c735c Mon Sep 17 00:00:00 2001
From: Brenden Matthews <brenden@diddyinc.com>
Date: Sat, 8 Dec 2018 17:45:17 -0500
Subject: [PATCH] Fix for #691, nullptr deref & race condition. (#692)

* Fix race condition in gw_info handling.
 * Fix a couple potential nullptr derefs.
 * Fix font handling without x.
 * Fix regression in output to ncurses with X disabled.
 * Apply some formatting/code smell fixes.
---
 .gitignore      |   4 +
 src/conky.cc    | 488 ++++++++++++++++++++++++------------------------
 src/fonts.cc    |  66 ++++++-
 src/fonts.h     |  27 +--
 src/linux.cc    | 169 ++++++++++-------
 src/specials.cc | 191 ++++++-------------
 6 files changed, 466 insertions(+), 479 deletions(-)

diff --git a/.gitignore b/.gitignore
index a507d0fb..125829b6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,3 +19,7 @@ lua/libimlib2.c
 *.so
 *.a
 /config.h
+
+# Ignore vscode stuff
+.vscode
+*.code-workspace
diff --git a/src/conky.cc b/src/conky.cc
index b5d607a7..04284d8b 100644
--- a/src/conky.cc
+++ b/src/conky.cc
@@ -27,6 +27,7 @@
  *
  */
 
+#include "conky.h"
 #include <algorithm>
 #include <cerrno>
 #include <climits>
@@ -42,7 +43,6 @@
 #include <vector>
 #include "common.h"
 #include "config.h"
-#include "conky.h"
 #include "text_object.h"
 #ifdef HAVE_DIRENT_H
 #include <dirent.h>
@@ -188,11 +188,11 @@ static conky::simple_config_setting<bool> format_human_readable(
 conky::simple_config_setting<bool> out_to_stdout("out_to_console",
 // Default value is false, unless we are building without X
 #ifdef BUILD_X11
-                                                        false,
+                                                 false,
 #else
-                                                        true,
+                                                 true,
 #endif
-                                                        false);
+                                                 false);
 static conky::simple_config_setting<bool> out_to_stderr("out_to_stderr", false,
                                                         false);
 
@@ -722,7 +722,7 @@ int spaced_print(char *buf, int size, const char *format, int width, ...) {
       len = snprintf(buf, size, "%-*s", width, tempbuf);
       break;
   }
-  delete [] tempbuf;
+  delete[] tempbuf;
   return len;
 }
 
@@ -888,7 +888,7 @@ void generate_text_internal(char *p, int p_max_size, struct text_object root) {
   load_fonts(utf8_mode.get(*state));
 #endif /* BUILD_X11 */
 #ifdef BUILD_ICONV
-  delete [] buff_in;
+  delete[] buff_in;
 #endif /* BUILD_ICONV */
 }
 
@@ -1094,7 +1094,8 @@ static void update_text_area() {
     case MIDDLE_LEFT:
     case MIDDLE_RIGHT:
     case MIDDLE_MIDDLE:
-      y =  workarea[1] + (workarea[3] - workarea[1]) / 2 - text_height / 2 - gap_y.get(*state);
+      y = workarea[1] + (workarea[3] - workarea[1]) / 2 - text_height / 2 -
+          gap_y.get(*state);
       break;
   }
   switch (align) {
@@ -1114,7 +1115,8 @@ static void update_text_area() {
     case TOP_MIDDLE:
     case BOTTOM_MIDDLE:
     case MIDDLE_MIDDLE:
-      x = workarea[0] + (workarea[2] - workarea[0]) / 2 - text_width / 2 - gap_x.get(*state);
+      x = workarea[0] + (workarea[2] - workarea[0]) / 2 - text_width / 2 -
+          gap_x.get(*state);
       break;
   }
 #ifdef OWN_WINDOW
@@ -1412,267 +1414,262 @@ int draw_each_line_inner(char *s, int special_index, int last_special_applied) {
       for (int i = 0; i < special_index; i++) { current = current->next; }
       switch (current->type) {
 #ifdef BUILD_X11
-        case HORIZONTAL_LINE: {
-          int h = current->height;
-          int mid = font_ascent() / 2;
+        case HORIZONTAL_LINE:
+          if (out_to_x.get(*state)) {
+            int h = current->height;
+            int mid = font_ascent() / 2;
 
-          w = text_start_x + text_width - cur_x;
+            w = text_start_x + text_width - cur_x;
 
-          XSetLineAttributes(display, window.gc, h, LineSolid, CapButt,
-                             JoinMiter);
-          XDrawLine(display, window.drawable, window.gc, text_offset_x + cur_x,
-                    text_offset_y + cur_y - mid / 2, text_offset_x + cur_x + w,
-                    text_offset_y + cur_y - mid / 2);
+            XSetLineAttributes(display, window.gc, h, LineSolid, CapButt,
+                               JoinMiter);
+            XDrawLine(display, window.drawable, window.gc,
+                      text_offset_x + cur_x, text_offset_y + cur_y - mid / 2,
+                      text_offset_x + cur_x + w,
+                      text_offset_y + cur_y - mid / 2);
+          }
           break;
-        }
 
-        case STIPPLED_HR: {
-          int h = current->height;
-          char tmp_s = current->arg;
-          int mid = font_ascent() / 2;
-          char ss[2] = {tmp_s, tmp_s};
-
-          w = text_start_x + text_width - cur_x - 1;
-          XSetLineAttributes(display, window.gc, h, LineOnOffDash, CapButt,
-                             JoinMiter);
-          XSetDashes(display, window.gc, 0, ss, 2);
-          XDrawLine(display, window.drawable, window.gc, text_offset_x + cur_x,
-                    text_offset_y + cur_y - mid / 2, text_offset_x + cur_x + w,
-                    text_offset_x + cur_y - mid / 2);
+        case STIPPLED_HR:
+          if (out_to_x.get(*state)) {
+            int h = current->height;
+            char tmp_s = current->arg;
+            int mid = font_ascent() / 2;
+            char ss[2] = {tmp_s, tmp_s};
+
+            w = text_start_x + text_width - cur_x - 1;
+            XSetLineAttributes(display, window.gc, h, LineOnOffDash, CapButt,
+                               JoinMiter);
+            XSetDashes(display, window.gc, 0, ss, 2);
+            XDrawLine(display, window.drawable, window.gc,
+                      text_offset_x + cur_x, text_offset_y + cur_y - mid / 2,
+                      text_offset_x + cur_x + w,
+                      text_offset_x + cur_y - mid / 2);
+          }
           break;
-        }
 
-        case BAR: {
-          int h, by;
-          double bar_usage, scale;
-          if (cur_x - text_start_x > mw && mw > 0) { break; }
-          h = current->height;
-          bar_usage = current->arg;
-          scale = current->scale;
-          by = cur_y - (font_ascent() / 2) - 1;
-
-          if (h < font_h) { by -= h / 2 - 1; }
-          w = current->width;
-          if (w == 0) { w = text_start_x + text_width - cur_x - 1; }
-          if (w < 0) { w = 0; }
-
-          XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
-                             JoinMiter);
-
-          XDrawRectangle(display, window.drawable, window.gc,
-                         text_offset_x + cur_x, text_offset_y + by, w, h);
-          XFillRectangle(display, window.drawable, window.gc,
-                         text_offset_x + cur_x, text_offset_y + by,
-                         w * bar_usage / scale, h);
-          if (h > cur_y_add && h > font_h) { cur_y_add = h; }
+        case BAR:
+          if (out_to_x.get(*state)) {
+            int h, by;
+            double bar_usage, scale;
+            if (cur_x - text_start_x > mw && mw > 0) { break; }
+            h = current->height;
+            bar_usage = current->arg;
+            scale = current->scale;
+            by = cur_y - (font_ascent() / 2) - 1;
+
+            if (h < font_h) { by -= h / 2 - 1; }
+            w = current->width;
+            if (w == 0) { w = text_start_x + text_width - cur_x - 1; }
+            if (w < 0) { w = 0; }
+
+            XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
+                               JoinMiter);
+
+            XDrawRectangle(display, window.drawable, window.gc,
+                           text_offset_x + cur_x, text_offset_y + by, w, h);
+            XFillRectangle(display, window.drawable, window.gc,
+                           text_offset_x + cur_x, text_offset_y + by,
+                           w * bar_usage / scale, h);
+            if (h > cur_y_add && h > font_h) { cur_y_add = h; }
+          }
           break;
-        }
 
         case GAUGE: /* new GAUGE  */
-        {
-          int h, by = 0;
-          unsigned long last_colour = current_color;
+          if (out_to_x.get(*state)) {
+            int h, by = 0;
+            unsigned long last_colour = current_color;
 #ifdef BUILD_MATH
-          float angle, px, py;
-          double usage, scale;
+            float angle, px, py;
+            double usage, scale;
 #endif /* BUILD_MATH */
 
-          if (cur_x - text_start_x > mw && mw > 0) { break; }
+            if (cur_x - text_start_x > mw && mw > 0) { break; }
 
-          h = current->height;
-          by = cur_y - (font_ascent() / 2) - 1;
+            h = current->height;
+            by = cur_y - (font_ascent() / 2) - 1;
 
-          if (h < font_h) { by -= h / 2 - 1; }
-          w = current->width;
-          if (w == 0) { w = text_start_x + text_width - cur_x - 1; }
-          if (w < 0) { w = 0; }
+            if (h < font_h) { by -= h / 2 - 1; }
+            w = current->width;
+            if (w == 0) { w = text_start_x + text_width - cur_x - 1; }
+            if (w < 0) { w = 0; }
 
-          XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
-                             JoinMiter);
+            XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
+                               JoinMiter);
 
-          XDrawArc(display, window.drawable, window.gc, text_offset_x + cur_x,
-                   text_offset_y + by, w, h * 2, 0, 180 * 64);
+            XDrawArc(display, window.drawable, window.gc, text_offset_x + cur_x,
+                     text_offset_y + by, w, h * 2, 0, 180 * 64);
 
 #ifdef BUILD_MATH
-          usage = current->arg;
-          scale = current->scale;
-          angle = M_PI * usage / scale;
-          px = static_cast<float>(cur_x + (w / 2.)) -
-               static_cast<float>(w / 2.) * cos(angle);
-          py =
-              static_cast<float>(by + (h)) - static_cast<float>(h) * sin(angle);
-
-          XDrawLine(display, window.drawable, window.gc,
-                    text_offset_x + cur_x + (w / 2.), text_offset_y + by + (h),
-                    text_offset_x + static_cast<int>(px),
-                    text_offset_y + static_cast<int>(py));
+            usage = current->arg;
+            scale = current->scale;
+            angle = M_PI * usage / scale;
+            px = static_cast<float>(cur_x + (w / 2.)) -
+                 static_cast<float>(w / 2.) * cos(angle);
+            py = static_cast<float>(by + (h)) -
+                 static_cast<float>(h) * sin(angle);
+
+            XDrawLine(display, window.drawable, window.gc,
+                      text_offset_x + cur_x + (w / 2.),
+                      text_offset_y + by + (h),
+                      text_offset_x + static_cast<int>(px),
+                      text_offset_y + static_cast<int>(py));
 #endif /* BUILD_MATH */
 
-          if (h > cur_y_add && h > font_h) { cur_y_add = h; }
-
-          set_foreground_color(last_colour);
+            if (h > cur_y_add && h > font_h) { cur_y_add = h; }
 
+            set_foreground_color(last_colour);
+          }
           break;
-        }
 
-        case GRAPH: {
-          int h, by, i = 0, j = 0;
-          int colour_idx = 0;
-          unsigned long last_colour = current_color;
-          if (cur_x - text_start_x > mw && mw > 0) { break; }
-          h = current->height;
-          by = cur_y - (font_ascent() / 2) - 1;
-
-          if (h < font_h) { by -= h / 2 - 1; }
-          w = current->width;
-          if (w == 0) {
-            w = text_start_x + text_width - cur_x - 1;
-            current->graph_width = MAX(w - 1, 0);
-            if (current->graph_width != current->graph_allocated) {
-              w = current->graph_allocated + 1;
+        case GRAPH:
+          if (out_to_x.get(*state)) {
+            int h, by, i = 0, j = 0;
+            int colour_idx = 0;
+            unsigned long last_colour = current_color;
+            if (cur_x - text_start_x > mw && mw > 0) { break; }
+            h = current->height;
+            by = cur_y - (font_ascent() / 2) - 1;
+
+            if (h < font_h) { by -= h / 2 - 1; }
+            w = current->width;
+            if (w == 0) {
+              w = text_start_x + text_width - cur_x - 1;
+              current->graph_width = MAX(w - 1, 0);
+              if (current->graph_width != current->graph_allocated) {
+                w = current->graph_allocated + 1;
+              }
+            }
+            if (w < 0) { w = 0; }
+            if (draw_graph_borders.get(*state)) {
+              XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
+                                 JoinMiter);
+              XDrawRectangle(display, window.drawable, window.gc,
+                             text_offset_x + cur_x, text_offset_y + by, w, h);
             }
-          }
-          if (w < 0) { w = 0; }
-          if (draw_graph_borders.get(*state)) {
             XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
                                JoinMiter);
-            XDrawRectangle(display, window.drawable, window.gc,
-                           text_offset_x + cur_x, text_offset_y + by, w, h);
-          }
-          XSetLineAttributes(display, window.gc, 1, LineSolid, CapButt,
-                             JoinMiter);
 
-          /* in case we don't have a graph yet */
-          if (current->graph != nullptr) {
-            unsigned long *tmpcolour = nullptr;
+            /* in case we don't have a graph yet */
+            if (current->graph != nullptr) {
+              unsigned long *tmpcolour = nullptr;
 
-            if (current->last_colour != 0 || current->first_colour != 0) {
-              tmpcolour = do_gradient(w - 1, current->last_colour,
-                                      current->first_colour);
-            }
-            colour_idx = 0;
-            for (i = w - 2; i > -1; i--) {
               if (current->last_colour != 0 || current->first_colour != 0) {
-                if (current->tempgrad != 0) {
-#ifdef DEBUG_lol
-                  assert((int)((float)(w - 2) - current->graph[j] * (w - 2) /
-                                                    (float)current->scale) <
-                         w - 1);
-                  assert((int)((float)(w - 2) - current->graph[j] * (w - 2) /
-                                                    (float)current->scale) >
-                         -1);
-                  if (current->graph[j] == current->scale) {
-                    assert((int)((float)(w - 2) - current->graph[j] * (w - 2) /
-                                                      (float)current->scale) ==
-                           0);
+                tmpcolour = do_gradient(w - 1, current->last_colour,
+                                        current->first_colour);
+              }
+              colour_idx = 0;
+              for (i = w - 2; i > -1; i--) {
+                if (current->last_colour != 0 || current->first_colour != 0) {
+                  if (current->tempgrad != 0) {
+                    set_foreground_color(tmpcolour[static_cast<int>(
+                        static_cast<float>(w - 2) -
+                        current->graph[j] * (w - 2) /
+                            std::max(static_cast<float>(current->scale),
+                                     1.0F))]);
+                  } else {
+                    set_foreground_color(tmpcolour[colour_idx++]);
                   }
-#endif /* DEBUG_lol */
-                  set_foreground_color(tmpcolour[static_cast<int>(
-                      static_cast<float>(w - 2) -
-                      current->graph[j] * (w - 2) /
-                          std::max(static_cast<float>(current->scale), 1.0f))]);
-                } else {
-                  set_foreground_color(tmpcolour[colour_idx++]);
                 }
+                /* this is mugfugly, but it works */
+                XDrawLine(
+                    display, window.drawable, window.gc,
+                    text_offset_x + cur_x + i + 1, text_offset_y + by + h,
+                    text_offset_x + cur_x + i + 1,
+                    text_offset_y + round_to_int(static_cast<double>(by) + h -
+                                                 current->graph[j] * (h - 1) /
+                                                     current->scale));
+                ++j;
               }
-              /* this is mugfugly, but it works */
-              XDrawLine(
-                  display, window.drawable, window.gc,
-                  text_offset_x + cur_x + i + 1, text_offset_y + by + h,
-                  text_offset_x + cur_x + i + 1,
-                  text_offset_y + round_to_int(static_cast<double>(by) + h -
-                                               current->graph[j] * (h - 1) /
-                                                   current->scale));
-              ++j;
+              free_and_zero(tmpcolour);
             }
-            free_and_zero(tmpcolour);
-          }
-          if (h > cur_y_add && h > font_h) { cur_y_add = h; }
-          if (show_graph_range.get(*state)) {
-            int tmp_x = cur_x;
-            int tmp_y = cur_y;
-            unsigned short int seconds = active_update_interval() * w;
-            char *tmp_day_str;
-            char *tmp_hour_str;
-            char *tmp_min_str;
-            char *tmp_sec_str;
-            char *tmp_str;
-            unsigned short int timeunits;
-            if (seconds != 0) {
-              timeunits = seconds / 86400;
-              seconds %= 86400;
-              if (timeunits <= 0 ||
-                  asprintf(&tmp_day_str, _("%dd"), timeunits) == -1) {
-                tmp_day_str = strdup("");
-              }
-              timeunits = seconds / 3600;
-              seconds %= 3600;
-              if (timeunits <= 0 ||
-                  asprintf(&tmp_hour_str, _("%dh"), timeunits) == -1) {
-                tmp_hour_str = strdup("");
-              }
-              timeunits = seconds / 60;
-              seconds %= 60;
-              if (timeunits <= 0 ||
-                  asprintf(&tmp_min_str, _("%dm"), timeunits) == -1) {
-                tmp_min_str = strdup("");
-              }
-              if (seconds <= 0 ||
-                  asprintf(&tmp_sec_str, _("%ds"), seconds) == -1) {
-                tmp_sec_str = strdup("");
-              }
-              if (asprintf(&tmp_str, "%s%s%s%s", tmp_day_str, tmp_hour_str,
-                           tmp_min_str, tmp_sec_str) == -1) {
-                tmp_str = strdup("");
+            if (h > cur_y_add && h > font_h) { cur_y_add = h; }
+            if (show_graph_range.get(*state)) {
+              int tmp_x = cur_x;
+              int tmp_y = cur_y;
+              unsigned short int seconds = active_update_interval() * w;
+              char *tmp_day_str;
+              char *tmp_hour_str;
+              char *tmp_min_str;
+              char *tmp_sec_str;
+              char *tmp_str;
+              unsigned short int timeunits;
+              if (seconds != 0) {
+                timeunits = seconds / 86400;
+                seconds %= 86400;
+                if (timeunits <= 0 ||
+                    asprintf(&tmp_day_str, _("%dd"), timeunits) == -1) {
+                  tmp_day_str = strdup("");
+                }
+                timeunits = seconds / 3600;
+                seconds %= 3600;
+                if (timeunits <= 0 ||
+                    asprintf(&tmp_hour_str, _("%dh"), timeunits) == -1) {
+                  tmp_hour_str = strdup("");
+                }
+                timeunits = seconds / 60;
+                seconds %= 60;
+                if (timeunits <= 0 ||
+                    asprintf(&tmp_min_str, _("%dm"), timeunits) == -1) {
+                  tmp_min_str = strdup("");
+                }
+                if (seconds <= 0 ||
+                    asprintf(&tmp_sec_str, _("%ds"), seconds) == -1) {
+                  tmp_sec_str = strdup("");
+                }
+                if (asprintf(&tmp_str, "%s%s%s%s", tmp_day_str, tmp_hour_str,
+                             tmp_min_str, tmp_sec_str) == -1) {
+                  tmp_str = strdup("");
+                }
+                free(tmp_day_str);
+                free(tmp_hour_str);
+                free(tmp_min_str);
+                free(tmp_sec_str);
+              } else {
+                tmp_str = strdup(
+                    _("Range not possible"));  // should never happen, but
+                                               // better safe then sorry
               }
-              free(tmp_day_str);
-              free(tmp_hour_str);
-              free(tmp_min_str);
-              free(tmp_sec_str);
-            } else {
-              tmp_str =
-                  strdup(_("Range not possible"));  // should never happen, but
-                                                    // better safe then sorry
+              cur_x += (w / 2) - (font_ascent() * (strlen(tmp_str) / 2));
+              cur_y += font_h / 2;
+              draw_string(tmp_str);
+              free(tmp_str);
+              cur_x = tmp_x;
+              cur_y = tmp_y;
             }
-            cur_x += (w / 2) - (font_ascent() * (strlen(tmp_str) / 2));
-            cur_y += font_h / 2;
-            draw_string(tmp_str);
-            free(tmp_str);
-            cur_x = tmp_x;
-            cur_y = tmp_y;
-          }
 #ifdef BUILD_MATH
-          if (show_graph_scale.get(*state) && (current->show_scale == 1)) {
-            int tmp_x = cur_x;
-            int tmp_y = cur_y;
-            char *tmp_str;
-            cur_x += font_ascent() / 2;
-            cur_y += font_h / 2;
-            asprintf(&tmp_str, "%.1f", current->scale);
-            draw_string(tmp_str);
-            free(tmp_str);
-            cur_x = tmp_x;
-            cur_y = tmp_y;
-          }
+            if (show_graph_scale.get(*state) && (current->show_scale == 1)) {
+              int tmp_x = cur_x;
+              int tmp_y = cur_y;
+              char *tmp_str;
+              cur_x += font_ascent() / 2;
+              cur_y += font_h / 2;
+              asprintf(&tmp_str, "%.1f", current->scale);
+              draw_string(tmp_str);
+              free(tmp_str);
+              cur_x = tmp_x;
+              cur_y = tmp_y;
+            }
 #endif
-          set_foreground_color(last_colour);
+            set_foreground_color(last_colour);
+          }
           break;
-        }
 
-        case FONT: {
-          int old = font_ascent();
+        case FONT:
+          if (out_to_x.get(*state)) {
+            int old = font_ascent();
 
-          cur_y -= font_ascent();
-          selected_font = current->font_added;
-          set_font();
-          if (cur_y + font_ascent() < cur_y + old) {
-            cur_y += old;
-          } else {
-            cur_y += font_ascent();
+            cur_y -= font_ascent();
+            selected_font = current->font_added;
+            set_font();
+            if (cur_y + font_ascent() < cur_y + old) {
+              cur_y += old;
+            } else {
+              cur_y += font_ascent();
+            }
+            font_h = font_height();
           }
-          font_h = font_height();
           break;
-        }
 #endif /* BUILD_X11 */
         case FG:
           if (draw_mode == FG) { set_foreground_color(current->arg); }
@@ -1975,18 +1972,16 @@ static void update_text() {
 int inotify_fd = -1;
 #endif
 
-template<typename Out>
+template <typename Out>
 void split(const std::string &s, char delim, Out result) {
-    std::stringstream ss(s);
-    std::string item;
-    while (std::getline(ss, item, delim)) {
-        *(result++) = item;
-    }
+  std::stringstream ss(s);
+  std::string item;
+  while (std::getline(ss, item, delim)) { *(result++) = item; }
 }
- std::vector<std::string> split(const std::string &s, char delim) {
-    std::vector<std::string> elems;
-    split(s, delim, std::back_inserter(elems));
-    return elems;
+std::vector<std::string> split(const std::string &s, char delim) {
+  std::vector<std::string> elems;
+  split(s, delim, std::back_inserter(elems));
+  return elems;
 }
 
 bool is_on_battery() {  // checks if at least one battery specified in
@@ -1994,7 +1989,7 @@ bool is_on_battery() {  // checks if at least one battery specified in
   char buf[64];
   std::vector<std::string> b_items = split(detect_battery.get(*state), ',');
 
-   for(auto const& value: b_items) {
+  for (auto const &value : b_items) {
     get_battery_short_status(buf, 64, value.c_str());
     if (buf[0] == 'D') { return true; }
   }
@@ -2701,11 +2696,11 @@ void load_config_file() {
     l.pushstring(current_config.c_str());
     l.call(1, 1);
 #else
-  char *syntaxerr;
-  asprintf(&syntaxerr, _(SYNTAX_ERR_READ_CONF), e.what());
-  std::string syntaxerrobj(syntaxerr);
-  free(syntaxerr);
-  throw conky::error(syntaxerrobj);
+    char *syntaxerr;
+    asprintf(&syntaxerr, _(SYNTAX_ERR_READ_CONF), e.what());
+    std::string syntaxerrobj(syntaxerr);
+    free(syntaxerr);
+    throw conky::error(syntaxerrobj);
 #endif
   }
   l.call(0, 0);
@@ -2916,7 +2911,8 @@ void initialisation(int argc, char **argv) {
       case 'm':
         state->pushinteger(strtol(optarg, &conv_end, 10));
         if (*conv_end != 0) {
-          CRIT_ERR(nullptr, nullptr, "'%s' is a wrong xinerama-head index", optarg);
+          CRIT_ERR(nullptr, nullptr, "'%s' is a wrong xinerama-head index",
+                   optarg);
         }
         head_index.lua_set(*state);
         break;
@@ -3033,9 +3029,9 @@ void initialisation(int argc, char **argv) {
 
   text_buffer = new char[max_user_text.get(*state)];
   memset(text_buffer, 0, max_user_text.get(*state));
-  tmpstring1 = new char [text_buffer_size.get(*state)];
+  tmpstring1 = new char[text_buffer_size.get(*state)];
   memset(tmpstring1, 0, text_buffer_size.get(*state));
-  tmpstring2 = new char [text_buffer_size.get(*state)];
+  tmpstring2 = new char[text_buffer_size.get(*state)];
   memset(tmpstring2, 0, text_buffer_size.get(*state));
 
 #ifdef BUILD_X11
diff --git a/src/fonts.cc b/src/fonts.cc
index a8199b0e..a4b02ad6 100644
--- a/src/fonts.cc
+++ b/src/fonts.cc
@@ -1,4 +1,5 @@
 /*
+ad_
  *
  * Conky, a system monitor, based on torsmo
  *
@@ -49,11 +50,9 @@ void font_setting::lua_setter(lua::state &l, bool init) {
 
 font_setting font;
 
-conky::simple_config_setting<std::string> font_template[10] = {{"font0", ""}, {"font1", ""},
-                                                               {"font2", ""}, {"font3", ""},
-                                                               {"font4", ""}, {"font5", ""},
-                                                               {"font6", ""}, {"font7", ""},
-                                                               {"font8", ""}, {"font9", ""}};
+conky::simple_config_setting<std::string> font_template[10] = {
+    {"font0", ""}, {"font1", ""}, {"font2", ""}, {"font3", ""}, {"font4", ""},
+    {"font5", ""}, {"font6", ""}, {"font7", ""}, {"font8", ""}, {"font9", ""}};
 
 #ifdef BUILD_XFT
 namespace {
@@ -196,3 +195,60 @@ void load_fonts(bool utf8) {
     }
   }
 }
+
+#ifdef BUILD_XFT
+
+int font_height() {
+  if (!out_to_x.get(*state)) { return 0; }
+  assert(selected_font < fonts.size());
+  if (use_xft.get(*state)) {
+    return fonts[selected_font].xftfont->ascent +
+           fonts[selected_font].xftfont->descent;
+  } else {
+    return fonts[selected_font].font->max_bounds.ascent +
+           fonts[selected_font].font->max_bounds.descent;
+  }
+}
+
+int font_ascent() {
+  if (!out_to_x.get(*state)) { return 0; }
+  assert(selected_font < fonts.size());
+  if (use_xft.get(*state)) {
+    return fonts[selected_font].xftfont->ascent;
+  } else {
+    return fonts[selected_font].font->max_bounds.ascent;
+  }
+}
+
+int font_descent() {
+  if (!out_to_x.get(*state)) { return 0; }
+  assert(selected_font < fonts.size());
+  if (use_xft.get(*state)) {
+    return fonts[selected_font].xftfont->descent;
+  } else {
+    return fonts[selected_font].font->max_bounds.descent;
+  }
+}
+
+#else
+
+int font_height() {
+  if (!out_to_x.get(*state)) { return 0; }
+  assert(selected_font < fonts.size());
+  return fonts[selected_font].font->max_bounds.ascent +
+         fonts[selected_font].font->max_bounds.descent;
+}
+
+int font_ascent() {
+  if (!out_to_x.get(*state)) { return 0; }
+  assert(selected_font < fonts.size());
+  return fonts[selected_font].font->max_bounds.ascent;
+}
+
+int font_descent() {
+  if (!out_to_x.get(*state)) { return 0; }
+  assert(selected_font < fonts.size());
+  return fonts[selected_font].font->max_bounds.descent;
+}
+
+#endif
diff --git a/src/fonts.h b/src/fonts.h
index 81ef5beb..29de7e85 100644
--- a/src/fonts.h
+++ b/src/fonts.h
@@ -58,34 +58,13 @@ struct font_list {
   }
 };
 
-#ifdef BUILD_XFT
-
-#define font_height()                                                    \
-  (use_xft.get(*state) ? (fonts[selected_font].xftfont->ascent +         \
-                          fonts[selected_font].xftfont->descent)         \
-                       : (fonts[selected_font].font->max_bounds.ascent + \
-                          fonts[selected_font].font->max_bounds.descent))
-#define font_ascent()                                         \
-  (use_xft.get(*state) ? fonts[selected_font].xftfont->ascent \
-                       : fonts[selected_font].font->max_bounds.ascent)
-#define font_descent()                                         \
-  (use_xft.get(*state) ? fonts[selected_font].xftfont->descent \
-                       : fonts[selected_font].font->max_bounds.descent)
-
-#else
-
-#define font_height()                             \
-  (fonts[selected_font].font->max_bounds.ascent + \
-   fonts[selected_font].font->max_bounds.descent)
-#define font_ascent() fonts[selected_font].font->max_bounds.ascent
-#define font_descent() fonts[selected_font].font->max_bounds.descent
-
-#endif
-
 /* direct access to registered fonts (FIXME: bad encapsulation) */
 extern std::vector<font_list> fonts;
 extern unsigned int selected_font;
 
+int font_height();
+int font_ascent();
+int font_descent();
 void setup_fonts(void);
 void set_font(void);
 int add_font(const char *);
diff --git a/src/linux.cc b/src/linux.cc
index a9c65a86..da7085a9 100644
--- a/src/linux.cc
+++ b/src/linux.cc
@@ -24,6 +24,7 @@
  *
  */
 
+#include "linux.h"
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -34,7 +35,6 @@
 #include "common.h"
 #include "conky.h"
 #include "diskio.h"
-#include "linux.h"
 #include "logging.h"
 #include "net_stat.h"
 #include "proc.h"
@@ -62,6 +62,8 @@
 #include <linux/route.h>
 #include <math.h>
 #include <pthread.h>
+#include <atomic>
+#include <mutex>
 
 /* The following ifdefs were adapted from gkrellm */
 #include <linux/major.h>
@@ -229,7 +231,8 @@ int update_meminfo(void) {
   return 0;
 }
 
-void print_laptop_mode(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_laptop_mode(struct text_object *obj, char *p,
+                       unsigned int p_max_size) {
   FILE *fp;
   int val = -1;
 
@@ -246,7 +249,8 @@ void print_laptop_mode(struct text_object *obj, char *p, unsigned int p_max_size
  * # cat /sys/block/sda/queue/scheduler
  * noop [anticipatory] cfq
  */
-void print_ioscheduler(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_ioscheduler(struct text_object *obj, char *p,
+                       unsigned int p_max_size) {
   FILE *fp;
   char buf[128];
 
@@ -269,23 +273,38 @@ void print_ioscheduler(struct text_object *obj, char *p, unsigned int p_max_size
   return;
 }
 
-static struct {
+class gw_info_s {
+ public:
+  gw_info_s() : iface(nullptr), ip(nullptr), count(0) {}
   char *iface;
   char *ip;
-  int count;
-} gw_info;
+  std::atomic<int> count;
+  std::mutex mutex;
+
+  void reset() {
+    std::lock_guard<std::mutex> lock(mutex);
+    free_and_zero(iface);
+    free_and_zero(ip);
+  }
+};
+static gw_info_s gw_info;
 
-#define SAVE_SET_STRING(x, y)                              \
-  if (x && strcmp((char *)x, (char *)y)) {                 \
-    free(x);                                               \
-    x = strndup("multiple", text_buffer_size.get(*state)); \
-  } else if (!x) {                                         \
-    x = strndup(y, text_buffer_size.get(*state));          \
+char *save_set_string(char *x, char *y) {
+  if (x != nullptr && strcmp((char *)x, (char *)y)) {
+    free_and_zero(x);
+    x = strndup("multiple", text_buffer_size.get(*state));
+  } else if (x == nullptr && y != nullptr) {
+    x = strndup(y, text_buffer_size.get(*state));
   }
+  return x;
+}
 
 void update_gateway_info_failure(const char *reason) {
   if (reason != nullptr) { perror(reason); }
   // 2 pointers to 1 location causes a crash when we try to free them both
+  std::unique_lock lock(gw_info.mutex);
+  free_and_zero(gw_info.iface);
+  free_and_zero(gw_info.ip);
   gw_info.iface = strndup("failed", text_buffer_size.get(*state));
   gw_info.ip = strndup("failed", text_buffer_size.get(*state));
 }
@@ -320,10 +339,11 @@ int update_gateway_info2(void) {
   unsigned int z = 1;
   int strcmpreturn;
 
-  if((fp = check_procroute()) != nullptr) {
+  if ((fp = check_procroute()) != nullptr) {
     while (!feof(fp)) {
       strcmpreturn = 1;
-      if (fscanf(fp, RT_ENTRY_FORMAT, iface, &dest, &gate, &flags, &mask) != 5) {
+      if (fscanf(fp, RT_ENTRY_FORMAT, iface, &dest, &gate, &flags, &mask) !=
+          5) {
         update_gateway_info_failure("fscanf()");
         break;
       }
@@ -355,22 +375,23 @@ int update_gateway_info(void) {
   unsigned long dest, gate, mask;
   unsigned int flags;
 
-  free_and_zero(gw_info.iface);
-  free_and_zero(gw_info.ip);
+  gw_info.reset();
   gw_info.count = 0;
 
-  if((fp = check_procroute()) != nullptr) {
+  if ((fp = check_procroute()) != nullptr) {
     while (!feof(fp)) {
-      if (fscanf(fp, RT_ENTRY_FORMAT, iface, &dest, &gate, &flags, &mask) != 5) {
+      if (fscanf(fp, RT_ENTRY_FORMAT, iface, &dest, &gate, &flags, &mask) !=
+          5) {
         update_gateway_info_failure("fscanf()");
         break;
       }
       if (!(dest || mask) && ((flags & RTF_GATEWAY) || !gate)) {
         gw_info.count++;
         snprintf(e_iface, 49, "%s", iface);
-        SAVE_SET_STRING(gw_info.iface, iface)
+        std::unique_lock lock(gw_info.mutex);
+        gw_info.iface = save_set_string(gw_info.iface, iface);
         ina.s_addr = gate;
-        SAVE_SET_STRING(gw_info.ip, inet_ntoa(ina))
+        gw_info.ip = save_set_string(gw_info.ip, inet_ntoa(ina));
       }
     }
     fclose(fp);
@@ -380,10 +401,7 @@ int update_gateway_info(void) {
 
 void free_gateway_info(struct text_object *obj) {
   (void)obj;
-
-  free_and_zero(gw_info.iface);
-  free_and_zero(gw_info.ip);
-  memset(&gw_info, 0, sizeof(gw_info));
+  gw_info.reset();
 }
 
 int gateway_exists(struct text_object *obj) {
@@ -391,12 +409,15 @@ int gateway_exists(struct text_object *obj) {
   return !!gw_info.count;
 }
 
-void print_gateway_iface(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_gateway_iface(struct text_object *obj, char *p,
+                         unsigned int p_max_size) {
   (void)obj;
+  std::lock_guard<std::mutex> lock(gw_info.mutex);
   snprintf(p, p_max_size, "%s", gw_info.iface);
 }
 
-void print_gateway_iface2(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_gateway_iface2(struct text_object *obj, char *p,
+                          unsigned int p_max_size) {
   long int z = 0;
   unsigned int x = 1;
   unsigned int found = 0;
@@ -405,9 +426,7 @@ void print_gateway_iface2(struct text_object *obj, char *p, unsigned int p_max_s
 
   if (0 == strcmp(obj->data.s, "")) {
     for (; x < iface_len - 1; x++) {
-      if (0 == strcmp("", interfaces_arr[x])) {
-        break;
-      }
+      if (0 == strcmp("", interfaces_arr[x])) { break; }
       buf_ptr += snprintf(buf_ptr, iface_len - 1, "%s, ", interfaces_arr[x]);
       found = 1;
     }
@@ -420,14 +439,13 @@ void print_gateway_iface2(struct text_object *obj, char *p, unsigned int p_max_s
   }
 
   z = strtol(obj->data.s, (char **)NULL, 10);
-  if ((iface_len - 1) > z) {
-    snprintf(p, p_max_size, "%s", interfaces_arr[z]);
-  }
+  if ((iface_len - 1) > z) { snprintf(p, p_max_size, "%s", interfaces_arr[z]); }
 }
 
-void print_gateway_ip(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_gateway_ip(struct text_object *obj, char *p,
+                      unsigned int p_max_size) {
   (void)obj;
-
+  std::lock_guard<std::mutex> lock(gw_info.mutex);
   snprintf(p, p_max_size, "%s", gw_info.ip);
 }
 
@@ -1025,7 +1043,8 @@ int update_cpu_usage(void) {
   return 0;
 }
 
-void free_cpu(struct text_object *) { /* no-op */ }
+void free_cpu(struct text_object *) { /* no-op */
+}
 
 // fscanf() that reads floats with points even if you are using a locale where
 // floats are with commas
@@ -1322,7 +1341,8 @@ PARSER_GENERATOR(i2c, "/sys/bus/i2c/devices/")
 PARSER_GENERATOR(hwmon, "/sys/class/hwmon/")
 PARSER_GENERATOR(platform, "/sys/bus/platform/devices/")
 
-void print_sysfs_sensor(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_sysfs_sensor(struct text_object *obj, char *p,
+                        unsigned int p_max_size) {
   double r;
   struct sysfs *sf = (struct sysfs *)obj->data.opaque;
 
@@ -1512,12 +1532,14 @@ static char get_voltage(char *p_client_buffer, size_t client_buffer_size,
   return 1;
 }
 
-void print_voltage_mv(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_voltage_mv(struct text_object *obj, char *p,
+                      unsigned int p_max_size) {
   static int ok = 1;
   if (ok) { ok = get_voltage(p, p_max_size, "%.0f", 1, obj->data.i); }
 }
 
-void print_voltage_v(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_voltage_v(struct text_object *obj, char *p,
+                     unsigned int p_max_size) {
   static int ok = 1;
   if (ok) { ok = get_voltage(p, p_max_size, "%'.3f", 1000, obj->data.i); }
 }
@@ -2341,8 +2363,14 @@ static FILE *pmu_info_fp;
 static char pb_battery_info[3][32];
 static double pb_battery_info_update;
 
+void powerbook_update_status(unsigned int flags, int ac);
+void powerbook_update_percentage(long timeval, unsigned int flags, int ac,
+                                 int charge, int max_charge);
+void powerbook_update_time(long timeval);
+
 #define PMU_PATH "/proc/pmu"
-void get_powerbook_batt_info(struct text_object *obj, char *buffer, unsigned int n) {
+void get_powerbook_batt_info(struct text_object *obj, char *buffer,
+                             unsigned int n) {
   static int rep = 0;
   const char *batt_path = PMU_PATH "/battery_0";
   const char *info_path = PMU_PATH "/info";
@@ -2364,38 +2392,41 @@ void get_powerbook_batt_info(struct text_object *obj, char *buffer, unsigned int
     if (pmu_battery_fp == nullptr) { return; }
   }
 
-  if (pmu_battery_fp != nullptr) {
-    rewind(pmu_battery_fp);
-    while (!feof(pmu_battery_fp)) {
-      char buf[32];
+  rewind(pmu_battery_fp);
+  while (!feof(pmu_battery_fp)) {
+    char buf[32];
 
-      if (fgets(buf, sizeof(buf), pmu_battery_fp) == nullptr) { break; }
+    if (fgets(buf, sizeof(buf), pmu_battery_fp) == nullptr) { break; }
 
-      if (buf[0] == 'f') {
-        sscanf(buf, "flags      : %8x", &flags);
-      } else if (buf[0] == 'c' && buf[1] == 'h') {
-        sscanf(buf, "charge     : %d", &charge);
-      } else if (buf[0] == 'm') {
-        sscanf(buf, "max_charge : %d", &max_charge);
-      } else if (buf[0] == 't') {
-        sscanf(buf, "time rem.  : %ld", &timeval);
-      }
+    if (buf[0] == 'f') {
+      sscanf(buf, "flags      : %8x", &flags);
+    } else if (buf[0] == 'c' && buf[1] == 'h') {
+      sscanf(buf, "charge     : %d", &charge);
+    } else if (buf[0] == 'm') {
+      sscanf(buf, "max_charge : %d", &max_charge);
+    } else if (buf[0] == 't') {
+      sscanf(buf, "time rem.  : %ld", &timeval);
     }
   }
-  if (pmu_info_fp == nullptr) {
-    pmu_info_fp = open_file(info_path, &rep);
-    if (pmu_info_fp == nullptr) { return; }
-  }
+  pmu_info_fp = open_file(info_path, &rep);
+  if (pmu_info_fp == nullptr) { return; }
 
-  if (pmu_info_fp != nullptr) {
-    rewind(pmu_info_fp);
-    while (!feof(pmu_info_fp)) {
-      char buf[32];
+  rewind(pmu_info_fp);
+  while (!feof(pmu_info_fp)) {
+    char buf[32];
 
-      if (fgets(buf, sizeof(buf), pmu_info_fp) == nullptr) { break; }
-      if (buf[0] == 'A') { sscanf(buf, "AC Power               : %d", &ac); }
-    }
+    if (fgets(buf, sizeof(buf), pmu_info_fp) == nullptr) { break; }
+    if (buf[0] == 'A') { sscanf(buf, "AC Power               : %d", &ac); }
   }
+
+  powerbook_update_status(flags, ac);
+  powerbook_update_percentage(timeval, flags, ac, charge, max_charge);
+  powerbook_update_time(timeval);
+
+  snprintf(buffer, n, "%s", pb_battery_info[obj->data.i]);
+}
+
+void powerbook_update_status(unsigned int flags, int ac) {
   /* update status string */
   if ((ac && !(flags & PMU_BATT_PRESENT))) {
     strncpy(pb_battery_info[PB_BATT_STATUS], "AC",
@@ -2410,7 +2441,10 @@ void get_powerbook_batt_info(struct text_object *obj, char *buffer, unsigned int
     strncpy(pb_battery_info[PB_BATT_STATUS], "discharging",
             sizeof(pb_battery_info[PB_BATT_STATUS]));
   }
+}
 
+void powerbook_update_percentage(long timeval, unsigned int flags, int ac,
+                                 int charge, int max_charge) {
   /* update percentage string */
   if (timeval == 0 && ac && (flags & PMU_BATT_PRESENT) &&
       !(flags & PMU_BATT_CHARGING)) {
@@ -2424,7 +2458,9 @@ void get_powerbook_batt_info(struct text_object *obj, char *buffer, unsigned int
              sizeof(pb_battery_info[PB_BATT_PERCENT]), "%d%%",
              (charge * 100) / max_charge);
   }
+}
 
+void powerbook_update_time(long timeval) {
   /* update time string */
   if (timeval == 0) { /* fully charged or battery not present */
     snprintf(pb_battery_info[PB_BATT_TIME],
@@ -2436,8 +2472,6 @@ void get_powerbook_batt_info(struct text_object *obj, char *buffer, unsigned int
     format_seconds(pb_battery_info[PB_BATT_TIME],
                    sizeof(pb_battery_info[PB_BATT_TIME]), timeval);
   }
-
-  snprintf(buffer, n, "%s", pb_battery_info[obj->data.i]);
 }
 
 #define ENTROPY_AVAIL_PATH "/proc/sys/kernel/random/entropy_avail"
@@ -2555,7 +2589,8 @@ int update_diskio(void) {
   return 0;
 }
 
-void print_distribution(struct text_object *obj, char *p, unsigned int p_max_size) {
+void print_distribution(struct text_object *obj, char *p,
+                        unsigned int p_max_size) {
   (void)obj;
   int i, bytes_read;
   char *buf;
diff --git a/src/specials.cc b/src/specials.cc
index 774c3b8c..530c04fc 100644
--- a/src/specials.cc
+++ b/src/specials.cc
@@ -37,9 +37,9 @@
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif /* HAVE_SYS_PARAM_H */
-#include "colours.h"
 #include <algorithm>
 #include <sstream>
+#include "colours.h"
 #include "common.h"
 #include "conky.h"
 
@@ -227,9 +227,7 @@ char *scan_graph(struct text_object *obj, const char *args, double defscale) {
       quoted_cmd[_size] = '\0';
 
       /* copy everything after the last quote into argstr */
-      if (_size + 2 < strlen(args)) {
-        strncpy(argstr, args + _size + 2, 1023);
-      }
+      if (_size + 2 < strlen(args)) { strncpy(argstr, args + _size + 2, 1023); }
     } else {
       /* redundant, but simplifies the code below */
       strncpy(argstr, args, 1023);
@@ -326,9 +324,7 @@ char *scan_graph(struct text_object *obj, const char *args, double defscale) {
       sscanf(argstr, "%1023s %d,%d", buf, &g->height, &g->width);
     }
 
-    if ((*quoted_cmd == 0) && (*buf == 0)) {
-      return nullptr;
-    }
+    if ((*quoted_cmd == 0) && (*buf == 0)) { return nullptr; }
     return strndup(*quoted_cmd != 0 ? quoted_cmd : buf,
                    text_buffer_size.get(*state));
   }
@@ -361,15 +357,11 @@ struct special_t *new_special(char *buf, enum special_types t) {
 
   buf[0] = SPECIAL_CHAR;
   buf[1] = '\0';
-  if (specials == nullptr) {
-    specials = new_special_t_node();
-  }
+  if (specials == nullptr) { specials = new_special_t_node(); }
   current = specials;
   /* allocate special_count linked list elements */
   for (int i = 0; i < special_count; i++) {
-    if (current->next == nullptr) {
-      current->next = new_special_t_node();
-    }
+    if (current->next == nullptr) { current->next = new_special_t_node(); }
     current = current->next;
   }
   current->type = t;
@@ -377,8 +369,8 @@ struct special_t *new_special(char *buf, enum special_types t) {
   return current;
 }
 
-void new_gauge_in_shell(struct text_object *obj, char *p, unsigned int p_max_size,
-                        double usage) {
+void new_gauge_in_shell(struct text_object *obj, char *p,
+                        unsigned int p_max_size, double usage) {
   static const char *gaugevals[] = {"_. ", "\\. ", " | ", " ./", " ._"};
   auto *g = static_cast<struct gauge *>(obj->special_data);
 
@@ -390,13 +382,9 @@ void new_gauge_in_x11(struct text_object *obj, char *buf, double usage) {
   struct special_t *s = nullptr;
   auto *g = static_cast<struct gauge *>(obj->special_data);
 
-  if (not out_to_x.get(*state)) {
-    return;
-  }
+  if (!out_to_x.get(*state)) { return; }
 
-  if (g == nullptr) {
-    return;
-  }
+  if (g == nullptr) { return; }
 
   s = new_special(buf, GAUGE);
 
@@ -407,12 +395,11 @@ void new_gauge_in_x11(struct text_object *obj, char *buf, double usage) {
 }
 #endif /* BUILD_X11 */
 
-void new_gauge(struct text_object *obj, char *p, unsigned int p_max_size, double usage) {
+void new_gauge(struct text_object *obj, char *p, unsigned int p_max_size,
+               double usage) {
   auto *g = static_cast<struct gauge *>(obj->special_data);
 
-  if ((p_max_size == 0) || (g == nullptr)) {
-    return;
-  }
+  if ((p_max_size == 0) || (g == nullptr)) { return; }
 
   if ((g->flags & SF_SCALED) != 0) {
     g->scale = MAX(g->scale, usage);
@@ -421,13 +408,11 @@ void new_gauge(struct text_object *obj, char *p, unsigned int p_max_size, double
   }
 
 #ifdef BUILD_X11
-  if (out_to_x.get(*state)) {
-    new_gauge_in_x11(obj, p, usage);
-  }
+  if (out_to_x.get(*state)) { new_gauge_in_x11(obj, p, usage); }
   if (out_to_stdout.get(*state)) {
     new_gauge_in_shell(obj, p, p_max_size, usage);
   }
-#else /* BUILD_X11 */
+#else  /* BUILD_X11 */
   new_gauge_in_shell(obj, p, p_max_size, usage);
 #endif /* BUILD_X11 */
 }
@@ -437,13 +422,9 @@ void new_font(struct text_object *obj, char *p, unsigned int p_max_size) {
   struct special_t *s;
   unsigned int tmp = selected_font;
 
-  if (not out_to_x.get(*state)) {
-    return;
-  }
+  if (!out_to_x.get(*state)) { return; }
 
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
 
   s = new_special(p, FONT);
 
@@ -466,9 +447,7 @@ static void graph_append(struct special_t *graph, double f, char showaslog) {
   int i;
 
   /* do nothing if we don't even have a graph yet */
-  if (graph->graph == nullptr) {
-    return;
-  }
+  if (graph->graph == nullptr) { return; }
 
   if (showaslog != 0) {
 #ifdef BUILD_MATH
@@ -476,9 +455,7 @@ static void graph_append(struct special_t *graph, double f, char showaslog) {
 #endif
   }
 
-  if ((graph->scaled == 0) && f > graph->scale) {
-    f = graph->scale;
-  }
+  if ((graph->scaled == 0) && f > graph->scale) { f = graph->scale; }
 
   /* shift all the data by 1 */
   for (i = graph->graph_allocated - 1; i > 0; i--) {
@@ -505,9 +482,7 @@ void new_graph_in_shell(struct special_t *s, char *buf, int buf_max_size) {
   std::stringstream ss(ticks);
   std::string tickitem;
   std::vector<std::string> tickitems;
-  while (std::getline(ss, tickitem, ',')) {
-    tickitems.push_back(tickitem);
-  }
+  while (std::getline(ss, tickitem, ',')) { tickitems.push_back(tickitem); }
 
   char *p = buf;
   char *buf_max = buf + (sizeof(char) * buf_max_size);
@@ -518,9 +493,7 @@ void new_graph_in_shell(struct special_t *s, char *buf, int buf_max_size) {
     size_t itemlen = tickitems[v].size();
     for (unsigned int j = 0; j < itemlen; j++) {
       *p++ = tick[j];
-      if (p == buf_max) {
-        goto graph_buf_end;
-      }
+      if (p == buf_max) { goto graph_buf_end; }
     }
   }
 graph_buf_end:
@@ -540,17 +513,13 @@ void new_graph(struct text_object *obj, char *buf, int buf_max_size,
   struct special_t *s = nullptr;
   auto *g = static_cast<struct graph *>(obj->special_data);
 
-  if ((g == nullptr) || (buf_max_size == 0)) {
-    return;
-  }
+  if ((g == nullptr) || (buf_max_size == 0)) { return; }
 
   s = new_special(buf, GRAPH);
 
   /* set graph (special) width to width in obj */
   s->width = g->width;
-  if (s->width != 0) {
-    s->graph_width = s->width;
-  }
+  if (s->width != 0) { s->graph_width = s->width; }
 
   if (s->graph_width != s->graph_allocated) {
     auto *graph = static_cast<double *>(
@@ -587,25 +556,17 @@ void new_graph(struct text_object *obj, char *buf, int buf_max_size,
   }
   s->tempgrad = g->tempgrad;
 #ifdef BUILD_MATH
-  if ((g->flags & SF_SHOWLOG) != 0) {
-    s->scale = log10(s->scale + 1);
-  }
+  if ((g->flags & SF_SHOWLOG) != 0) { s->scale = log10(s->scale + 1); }
 #endif
   graph_append(s, val, g->flags);
 
-  if (out_to_stdout.get(*state)) {
-    new_graph_in_shell(s, buf, buf_max_size);
-  }
+  if (out_to_stdout.get(*state)) { new_graph_in_shell(s, buf, buf_max_size); }
 }
 
 void new_hr(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (not out_to_x.get(*state)) {
-    return;
-  }
+  if (!out_to_x.get(*state)) { return; }
 
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
 
   new_special(p, HORIZONTAL_LINE)->height = obj->data.l;
 }
@@ -624,23 +585,18 @@ void scan_stippled_hr(struct text_object *obj, const char *arg) {
       sscanf(arg, "%d", &sh->height);
     }
   }
-  if (sh->arg <= 0) {
-    sh->arg = 1;
-  }
+  if (sh->arg <= 0) { sh->arg = 1; }
   obj->special_data = sh;
 }
 
-void new_stippled_hr(struct text_object *obj, char *p, unsigned int p_max_size) {
+void new_stippled_hr(struct text_object *obj, char *p,
+                     unsigned int p_max_size) {
   struct special_t *s = nullptr;
   auto *sh = static_cast<struct stippled_hr *>(obj->special_data);
 
-  if (not out_to_x.get(*state)) {
-    return;
-  }
+  if (!out_to_x.get(*state)) { return; }
 
-  if ((sh == nullptr) || (p_max_size == 0)) {
-    return;
-  }
+  if ((sh == nullptr) || (p_max_size == 0)) { return; }
 
   s = new_special(p, STIPPLED_HR);
 
@@ -651,14 +607,10 @@ void new_stippled_hr(struct text_object *obj, char *p, unsigned int p_max_size)
 
 void new_fg(struct text_object *obj, char *p, unsigned int p_max_size) {
 #ifdef BUILD_X11
-  if (out_to_x.get(*state)) {
-    new_special(p, FG)->arg = obj->data.l;
-  }
+  if (out_to_x.get(*state)) { new_special(p, FG)->arg = obj->data.l; }
 #endif /* BUILD_X11 */
 #ifdef BUILD_NCURSES
-  if (out_to_ncurses.get(*state)) {
-    new_special(p, FG)->arg = obj->data.l;
-  }
+  if (out_to_ncurses.get(*state)) { new_special(p, FG)->arg = obj->data.l; }
 #endif /* BUILD_NCURSES */
   UNUSED(obj);
   UNUSED(p);
@@ -667,13 +619,9 @@ void new_fg(struct text_object *obj, char *p, unsigned int p_max_size) {
 
 #ifdef BUILD_X11
 void new_bg(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (not out_to_x.get(*state)) {
-    return;
-  }
+  if (!out_to_x.get(*state)) { return; }
 
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
 
   new_special(p, BG)->arg = obj->data.l;
 }
@@ -684,18 +632,12 @@ static void new_bar_in_shell(struct text_object *obj, char *buffer,
   auto *b = static_cast<struct bar *>(obj->special_data);
   unsigned int width, i, scaledusage;
 
-  if (b == nullptr) {
-    return;
-  }
+  if (b == nullptr) { return; }
 
   width = b->width;
-  if (width == 0) {
-    width = DEFAULT_BAR_WIDTH_NO_X;
-  }
+  if (width == 0) { width = DEFAULT_BAR_WIDTH_NO_X; }
 
-  if (width > buf_max_size) {
-    width = buf_max_size;
-  }
+  if (width > buf_max_size) { width = buf_max_size; }
 
   scaledusage = round_to_int(usage * width / b->scale);
 
@@ -703,9 +645,7 @@ static void new_bar_in_shell(struct text_object *obj, char *buffer,
     buffer[i] = *(bar_fill.get(*state).c_str());
   }
 
-  for (; i < width; i++) {
-    buffer[i] = *(bar_unfill.get(*state).c_str());
-  }
+  for (; i < width; i++) { buffer[i] = *(bar_unfill.get(*state).c_str()); }
 
   buffer[i] = 0;
 }
@@ -715,13 +655,9 @@ static void new_bar_in_x11(struct text_object *obj, char *buf, double usage) {
   struct special_t *s = nullptr;
   auto *b = static_cast<struct bar *>(obj->special_data);
 
-  if (not out_to_x.get(*state)) {
-    return;
-  }
+  if (!out_to_x.get(*state)) { return; }
 
-  if (b == nullptr) {
-    return;
-  }
+  if (b == nullptr) { return; }
 
   s = new_special(buf, BAR);
 
@@ -733,12 +669,11 @@ static void new_bar_in_x11(struct text_object *obj, char *buf, double usage) {
 #endif /* BUILD_X11 */
 
 /* usage is in range [0,255] */
-void new_bar(struct text_object *obj, char *p, unsigned int p_max_size, double usage) {
+void new_bar(struct text_object *obj, char *p, unsigned int p_max_size,
+             double usage) {
   auto *b = static_cast<struct bar *>(obj->special_data);
 
-  if ((p_max_size == 0) || (b == nullptr)) {
-    return;
-  }
+  if ((p_max_size == 0) || (b == nullptr)) { return; }
 
   if ((b->flags & SF_SCALED) != 0) {
     b->scale = MAX(b->scale, usage);
@@ -747,57 +682,43 @@ void new_bar(struct text_object *obj, char *p, unsigned int p_max_size, double u
   }
 
 #ifdef BUILD_X11
-  if (out_to_x.get(*state)) {
-    new_bar_in_x11(obj, p, usage);
-  }
+  if (out_to_x.get(*state)) { new_bar_in_x11(obj, p, usage); }
   if (out_to_stdout.get(*state)) {
     new_bar_in_shell(obj, p, p_max_size, usage);
   }
-#else /* BUILD_X11 */
+#else  /* BUILD_X11 */
   new_bar_in_shell(obj, p, p_max_size, usage);
 #endif /* BUILD_X11 */
 }
 
 void new_outline(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
   new_special(p, OUTLINE)->arg = obj->data.l;
 }
 
 void new_offset(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
   new_special(p, OFFSET)->arg = obj->data.l;
 }
 
 void new_voffset(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
   new_special(p, VOFFSET)->arg = obj->data.l;
 }
 
 void new_alignr(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
   new_special(p, ALIGNR)->arg = obj->data.l;
 }
 
 // A postive offset pushes the text further left
 void new_alignc(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
   new_special(p, ALIGNC)->arg = obj->data.l;
 }
 
 void new_goto(struct text_object *obj, char *p, unsigned int p_max_size) {
-  if (p_max_size == 0) {
-    return;
-  }
+  if (p_max_size == 0) { return; }
   new_special(p, GOTO)->arg = obj->data.l;
 }
 
@@ -815,9 +736,7 @@ void scan_tab(struct text_object *obj, const char *arg) {
       sscanf(arg, "%d", &t->arg);
     }
   }
-  if (t->width <= 0) {
-    t->width = 1;
-  }
+  if (t->width <= 0) { t->width = 1; }
   obj->special_data = t;
 }
 
@@ -825,9 +744,7 @@ void new_tab(struct text_object *obj, char *p, unsigned int p_max_size) {
   struct special_t *s = nullptr;
   auto *t = static_cast<struct tab *>(obj->special_data);
 
-  if ((t == nullptr) || (p_max_size == 0)) {
-    return;
-  }
+  if ((t == nullptr) || (p_max_size == 0)) { return; }
 
   s = new_special(p, TAB);
   s->width = t->width;
